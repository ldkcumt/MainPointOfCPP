# [知识点]

<b><details><summary>1.结构体与类的区别</summary></b> 

* 分别以struct和class命名

* 成员访问控制有差异，默认情况下，结构体的成员是public，类的成员是private

</details>

<b><details><summary>2.C++的特性?</summary></b> 

> 类与对象
>> 类是抽象的，对象是类的实例

> 构造函数
>> 
- 构造函数的名字和类名相同，没有返回值
- 构造函数用来对类中的成员变量进行初始化

> 析构函数
>>
- 释放对象所占有的资源
- 反向的构造函数，不允许有返回值
- 不能带参数，一个类中有且只有一个析构函数

> 函数的重载 overload
>>
- 有多个构造函数，函数名一样，只是参数的类型和个数不一样
- 只有函数的返回类型不同是不能构成函数的重载

> this指针
>>
- 是一个隐含的指针
- 指向对象本身，代表对象的地址

> 类的继承
>>
- 父类和子类，子类除了自己的成员变量和方法外，还可以继承父类的成员变量和方法
- public：可以在任何地方被访问
- protected：只能在该类及其子类中访问
- Private：只能在该类中访问

> 多重继承
>>
- 一个类可以从多个基类中派生
- 多个基类中若有相同的变量和方法，可能会带来麻烦

> 虚函数与多态
>>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型类调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

> 纯虚函数
>>
- 不具体实现的虚函数
- 含有纯虚函数的类叫抽象类，这种类不能声明对象，只是作为基类为派生类服务
- 派生类中必须完全实现基类的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。

> 函数的覆盖
>>
- 基类函数必须是虚函数
- 发生覆盖的两个函数要分别位于派生类和基类中
- 函数名称与参数必须完全相同
- 覆盖总是和多态关联在一起

> 函数的隐藏
>>
- 派生类的函数与基类函数完全相同，即函数名和参数都相同，只是基类函数没有使用virtual关键字，此时基类函数将被隐藏
- 派生类函数与基类函数同名，但参数不同，不管基类的函数是否有virtual关键字，基类函数都将被隐藏

> 引用和指针变量
>>
- 引用就是一个变量的别名
- 指针是地址，指针变量要存储地址值，可以修改指针变量所保存的地址值，从而指向其他的内存

</details>

<b><details><summary>3.Const char* 和 char* const</summary></b> 
- Const char* 指向常量的指针
- Char* const 指针常量

</details>

<b><details><summary>4.进程间通信方式</summary></b> 
- 剪贴板
- 匿名管道
- 命名管道
- 邮槽

</details>

<b><details><summary>5.线程同步</summary></b> 
- 利用事件对象实现线程同步
- 利用关键代码段实现线程同步
- 线程锁

</details>

<b><details><summary>6.指针</summary></b> 
- 一个整型数

    int a;

- 一个指向整型数的指针（A pointer to an integer）

    int *a;

- 一个指向指针的的指针，它指向的指针是指向一个整型数( A pointer to a pointer to an intege)

    int **a;

- 一个有10个整型数的数组( An array of 10 integers) 

    int a[10];

- 一个有10个指针的数组，该指针是指向一个整型数的。(An array of 10 pointers to integers) 

    int *a[10];

    本质上就是数组元素是10个 int * 指针的一维数组;先找到声明符a，然后向右看，有 [ ] 说明a是个数组，在向左看，是 int* ，说明数组里面的每个元素都是int*。所以这是一个存放 int* 指针的数组。

- 一个指向有10个整型数数组的指针( A pointer to an array of 10 integers)

    int (*a)[10];

    a是指针，指向一个数组，此数组里面有10个int型元素。

- 一个指向函数的指针，该函数有一个整型参数并返回一个整型数(A pointer to a function that takes an integer as an argument and returns an integer) 

    int (*a)(int);

- 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数( An array of ten pointers to functions that take an integer argument and return an integer )

    int (*a[10])(int)

</details>

<b><details><summary>7.与零值比较</summary></b> 

- 布尔变量与零值比较

    不可将布尔变量直接与TRUE、FALSE或者1、0进行比较

    if(flag)    //表示flag为真

    if(!flag)   //表示flag为假

- 整型变量与零值比较

    应当将整型变量用“==”或“！=”直接与0比较

    if(value == 0)

    if(value != 0)

- 浮点变量与零值比较

    不可将浮点变量用“==”或“！=”与任何数字比较；无论是float还是double类型的变量，都有精度限制。所以一定要避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“> =”或“ <=”形式。

    假设浮点变量的名字为x，应当将 

        if(x == 0.0)   //隐含错误的比较

    转化为

        const float EPSINON = 0.00001；

        if((x> =-EPSINON) && (x <=EPSINON))     //其中EPSINON是允许的误差（即精度）

- 指针变量与零值比较

    应当将指针变量用“==”或“！=”与NULL比较。指针变量的零值是“空”（记为NULL）。尽管NULL的值与0相同，但是两者意义不同。

    假设指针变量的名字为p，它与零值比较的标准if语句如下： 

    if(p == NULL) //   p与NULL显式比较，强调p是指针变量 

    if(p != NULL) 

- 对if语句的补充说明

</details>

<b><details><summary>8.写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。</summary></b> 

    #define MIN(a, b)(((a) >= (b)) ? (b) : (a))

    一定要加括号，如果不加括号，处理一些运算符会比较麻烦

</details>

<b><details><summary>9.a++与++a的区别</summary></b> 

    ++自增运算符：如a++，++a都等价于a = a + 1；

    -–自减运算符：如a–-，--a都等价于a = a -1；

    虽然++a和a++等价的结果一样，但是运算过程不同，a++ 是先使用a的值，然后再对a做加1处理，++a是先对a作加1处理，然后再使用a的值。

    int a = 5, b, c;

    b = a++;    //a值一开始为5，先赋值给b，所以b为5；然后a再做自加运算，所以a的值最终为6

    c = ++a;    //接上一步，a一开始为6，先执行自加运算，故a值变为7，再赋值给c，所以c的值也为7

</details>

<b><details><summary>对于派生类的构造函数，在定义对象时构造函数的执行顺序</summary></b> 

- 当派生类中不含对象成员时

    在创建派生类对象时,构造函数的执行顺序是：基类的构造函数→派生类的构造函数；

    在撤消派生类对象时,析构函数的执行顺序是：派生类的构造函数→基类的构造函数。

- 当派生类中含有对象成员时

     在定义派生类对象时，执行顺序：基类的构造函数→对象成员的构造函数→派生类的构造函数；

     在撤消派生类对象时，执行顺序：派生类的构造函数→对象成员的构造函数→基类的构造函数。

</details>

<b><details><summary>sizeof和strlen区别</summary></b>
>sizeof
>> 
- sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。
- 它的功能是，获得保证能容纳实现所建立的最大对象的字节大小
- 由于在编译时计算，因此它不能用来返回动态分配的内存空间的大小。实际上，用它来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。
- 具体而言，当参数分别如下时，它返回的值表示的含义如下：

    数组：编译时分配的数组空间大小

    指针：存储该指针所用的空间大小（存储该指针的地址的长度，是长整形，应该为4）

    类型：该类型所占的空间大小

    对象：对象的实际占用空间大小

    函数：函数的返回类型所占的空间大小，该函数的返回类型不能是void

>strlen
>>
- strlen(...)是函数，要在运行时才能计算。
- 参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。
- 它的功能是返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的
- 该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL，返回的长度大小不包括NULL

</details>

<b><details><summary>'\0'的含义</summary></b> 

- '\0'是判定字符数组结束的标识，表示这串字符到结尾了；
- 在字符数组中’\0’是占一个位置的！
- 例如 定义char c[6]=“hello”，而在内存中字符数组 c 则是"hello\0"；即’\0’在数组中占有空间却不被我们看到；
- 所以如果一个长度为10的字符串要放在字符数组里的话就应该把字符数组的长度定义为11

</details>

# [测试题]

<b><details><summary>一个指向整型数的指针</summary></b> 

    分别以struct和class命名

</details>
